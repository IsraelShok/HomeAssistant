// chnl v0.4.2 by Vitaliy Potapov
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (global = global || self, global.Channel = factory());
}(this, function () { 'use strict';

  function _typeof(obj) {
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof = function (obj) {
        return typeof obj;
      };
    } else {
      _typeof = function (obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }

    return _typeof(obj);
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
  }

  function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
  }

  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf(o, p);
  }

  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _possibleConstructorReturn(self, call) {
    if (call && (typeof call === "object" || typeof call === "function")) {
      return call;
    }

    return _assertThisInitialized(self);
  }

  var innerEvents = ['onListenerAdded', 'onListenerRemoved', 'onFirstListenerAdded', 'onLastListenerRemoved'];
  /**
   * Channel of particular events. Allows attach/detach listeners and dispatch event data.
   *
   * @param {String} [name]
   * @param {Boolean} [noInnerEvents]
   *
   * @example
   * import Channel from 'chnl';
   *
   * // create channel
   * const onMyEvent = new Channel();
   * // listen
   * onMyEvent.addListener(data => console.log(data));
   * // dispatch data
   * onMyEvent.dispatch(data);
   */

  var Channel =
  /*#__PURE__*/
  function () {
    function Channel(name, noInnerEvents) {
      var _this = this;

      _classCallCheck(this, Channel);

      this._listeners = [];
      this._mute = false;
      this._accumulate = false;
      this._accumulatedEvents = [];
      this._name = name || '';
      this._noInnerEvents = Boolean(noInnerEvents);

      if (!noInnerEvents) {
        innerEvents.forEach(function (eventName) {
          return _this[eventName] = new Channel(eventName, true);
        });
      }
    }
    /**
     * Add listener for event
     * @param {Function} callback
     * @param {Object} [context]
     */


    _createClass(Channel, [{
      key: "addListener",
      value: function addListener(callback, context) {
        this._pushListener(callback, context, false);
      }
      /**
       * Add once listener for event
       * @param {Function} callback
       * @param {Object} [context]
       */

    }, {
      key: "addOnceListener",
      value: function addOnceListener(callback, context) {
        this._pushListener(callback, context, true);
      }
      /**
       * Remove listener from event
       * @param {Function} callback
       * @param {Object} [context]
       */

    }, {
      key: "removeListener",
      value: function removeListener(callback, context) {
        this._ensureFunction(callback);

        var index = this._indexOfListener(callback, context);

        if (index >= 0) {
          this._spliceListener(index);
        }
      }
      /**
       * Remove all listeners from channel.
       */

    }, {
      key: "removeAllListeners",
      value: function removeAllListeners() {
        while (this.hasListeners()) {
          this._spliceListener(0);
        }
      }
      /**
       * Is listener exist
       * @param {Function} callback
       * @param {Object} [context]
       * @returns {Boolean}
       */

    }, {
      key: "hasListener",
      value: function hasListener(callback, context) {
        this._ensureFunction(callback);

        return this._indexOfListener(callback, context) >= 0;
      }
      /**
       * Are there any listeners
       * @returns {Boolean}
       */

    }, {
      key: "hasListeners",
      value: function hasListeners() {
        return this._listeners.length > 0;
      }
      /**
       * Call all listeners with specified params
       */

    }, {
      key: "dispatch",
      value: function dispatch() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        this._invokeListeners({
          args: args,
          async: false
        });
      }
      /**
       * Call all listeners with specified params asynchronously
       */

    }, {
      key: "dispatchAsync",
      value: function dispatchAsync() {
        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }

        this._invokeListeners({
          args: args,
          async: true
        });
      }
      /**
       * Mute channel
       * @param {Object} [options]
       * @param {Boolean} [options.accumulate] accumulate events and call listeners after .unmute()
       */

    }, {
      key: "mute",
      value: function mute() {
        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        this._mute = true;

        if (options.accumulate) {
          this._accumulate = true;
        } else {
          this._accumulate = false;
          this._accumulatedEvents = [];
        }
      }
      /**
       * Unmute channel
       */

    }, {
      key: "unmute",
      value: function unmute() {
        this._mute = false;

        if (this._accumulate) {
          this._dispatchAccumulated();

          this._accumulate = false;
        }
      }
      /**
       * @param {Object} options
       * @param {Array} options.args
       * @param {Boolean} [options.async]
       * @private
       */

    }, {
      key: "_invokeListeners",
      value: function _invokeListeners() {
        var _this2 = this;

        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
          args: [],
          async: false
        };

        if (!this._mute) {
          // ToDo: block adding/removing listeners to channel (throw an error) during dispatch operation
          var listnersToInvoke = this._listeners.slice();

          listnersToInvoke.forEach(function (listener) {
            _this2._invokeListener(listener, options);

            if (listener.once) {
              _this2.removeListener(listener.callback, listener.context);
            }
          });
        } else if (this._accumulate) {
          this._accumulatedEvents.push(options);
        }
      }
      /**
       * @param {Object} listener
       * @param {Object} options
       * @param {Array} options.args
       * @param {Boolean} options.async
       * @private
       */

    }, {
      key: "_invokeListener",
      value: function _invokeListener(listener, options) {
        if (options.async) {
          setTimeout(function () {
            return listener.callback.apply(listener.context, options.args);
          }, 0);
        } else {
          listener.callback.apply(listener.context, options.args);
        }
      }
      /**
       * Ensure function
       * @param {Function} callback
       */

    }, {
      key: "_ensureFunction",
      value: function _ensureFunction(callback) {
        if (typeof callback !== 'function') {
          throw new Error('Channel ' + this._name + ': listener is not a function');
        }
      }
      /**
       * Dispatch inner events when listener is added
       * @private
       */

    }, {
      key: "_dispatchInnerAddEvents",
      value: function _dispatchInnerAddEvents() {
        if (!this._noInnerEvents) {
          this.onListenerAdded.dispatch.apply(this.onListenerAdded, arguments);

          if (this._listeners.length === 1) {
            this.onFirstListenerAdded.dispatch.apply(this.onFirstListenerAdded, arguments);
          }
        }
      }
      /**
       * Dispatch inner events when listener is removed
       * @private
       */

    }, {
      key: "_dispatchInnerRemoveEvents",
      value: function _dispatchInnerRemoveEvents() {
        if (!this._noInnerEvents) {
          this.onListenerRemoved.dispatch.apply(this.onListenerRemoved, arguments);

          if (this._listeners.length === 0) {
            this.onLastListenerRemoved.dispatch.apply(this.onLastListenerRemoved, arguments);
          }
        }
      }
      /**
       * Find listener index
       * @param {Function} callback
       * @param {Object} [context]
       * @private
       */

    }, {
      key: "_indexOfListener",
      value: function _indexOfListener(callback, context) {
        for (var i = 0; i < this._listeners.length; i++) {
          var listener = this._listeners[i];
          var equalCallbacks = listener.callback === callback;
          var emptyContexts = context === undefined && listener.context === undefined;
          var equalContexts = context === listener.context;

          if (equalCallbacks && (emptyContexts || equalContexts)) {
            return i;
          }
        }
      }
      /**
       * Dispatch accumulated events
       * @private
       */

    }, {
      key: "_dispatchAccumulated",
      value: function _dispatchAccumulated() {
        var _this3 = this;

        this._accumulatedEvents.forEach(function (options) {
          return _this3._invokeListeners(options);
        });

        this._accumulatedEvents = [];
      }
      /**
       * Pushes listener
       * @param {Function} callback
       * @param {Object} context
       * @param {Boolean} once
       */

    }, {
      key: "_pushListener",
      value: function _pushListener(callback, context, once) {
        this._ensureFunction(callback);

        this._listeners.push({
          callback: callback,
          context: context,
          once: once
        });

        this._dispatchInnerAddEvents.apply(this, arguments);
      }
      /**
       * Splice listener under index
       * @param {Number} index
       */

    }, {
      key: "_spliceListener",
      value: function _spliceListener(index) {
        var listener = this._listeners[index];

        this._listeners.splice(index, 1);

        var args = [listener.callback];

        if (listener.context) {
          args.push(listener.context);
        }

        this._dispatchInnerRemoveEvents.apply(this, args);
      }
    }]);

    return Channel;
  }();

  /**
   * Event emitter similar to Node.js [EventEmitter](https://nodejs.org/api/events.html#events_class_eventemitter).
   * The main difference from single channel is that each method takes additional `event` argument.
   *
   * @example
   * import Channel from 'chnl';
   *
   * // create emitter
   * const emitter = new Channel.EventEmitter();
   * // listen 'myEvent'
   * emitter.on('myEvent', data => console.log(data));
   * // emit 'myEvent'
   * emitter.emit('myEvent', 'hello world!');
   */

  var EventEmitter =
  /*#__PURE__*/
  function () {
    function EventEmitter() {
      _classCallCheck(this, EventEmitter);

      this._channels = new Map();
    }
    /**
     * Adds listener to specific event
     *
     * @param {String} event
     * @param {Function} callback
     * @param {Object} [context]
     */


    _createClass(EventEmitter, [{
      key: "addListener",
      value: function addListener(event, callback, context) {
        this._getChannel(event).addListener(callback, context);
      }
      /**
       * Adds listener to specific event (alias to addListener)
       *
       * @param {String} event
       * @param {Function} callback
       * @param {Object} [context]
       */

    }, {
      key: "on",
      value: function on(event, callback, context) {
        this.addListener(event, callback, context);
      }
      /**
       * Adds once listener to specific event
       *
       * @param {String} event
       * @param {Function} callback
       * @param {Object} [context]
       */

    }, {
      key: "addOnceListener",
      value: function addOnceListener(event, callback, context) {
        this._getChannel(event).addOnceListener(callback, context);
      }
      /**
       * Adds once listener to specific event (alias to addOnceListener)
       *
       * @param {String} event
       * @param {Function} callback
       * @param {Object} [context]
       */

    }, {
      key: "once",
      value: function once(event, callback, context) {
        this.addOnceListener(event, callback, context);
      }
      /**
       * Removes listener from specific event
       *
       * @param {String} event
       * @param {Function} callback
       * @param {Object} [context]
       */

    }, {
      key: "removeListener",
      value: function removeListener(event, callback, context) {
        this._getChannel(event).removeListener(callback, context);
      }
      /**
       * Removes listener from specific event (alias to removeListener)
       *
       * @param {String} event
       * @param {Function} callback
       * @param {Object} [context]
       */

    }, {
      key: "off",
      value: function off(event, callback, context) {
        this.removeListener(event, callback, context);
      }
      /**
       * Is listener exist for specific event
       *
       * @param {String} event
       * @param {Function} callback
       * @param {Object} [context]
       * @returns {Boolean}
       */

    }, {
      key: "hasListener",
      value: function hasListener(event, callback, context) {
        return this._getChannel(event).hasListener(callback, context);
      }
      /**
       * Is listener exist for specific event (alias to hasListener)
       *
       * @param {String} event
       * @param {Function} callback
       * @param {Object} [context]
       * @returns {Boolean}
       */

    }, {
      key: "has",
      value: function has(event, callback, context) {
        return this.hasListener(event, callback, context);
      }
      /**
       * Are there any listeners for specific event
       *
       * @returns {Boolean}
       */

    }, {
      key: "hasListeners",
      value: function hasListeners(event) {
        return this._getChannel(event).hasListeners();
      }
      /**
       * Call all listeners for specific event
       *
       * @param {String} event
       * @param {*} args
       */

    }, {
      key: "dispatch",
      value: function dispatch(event) {
        var _this$_getChannel;

        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }

        (_this$_getChannel = this._getChannel(event)).dispatch.apply(_this$_getChannel, args);
      }
      /**
       * Call all listeners for specific event
       *
       * @param {String} event
       * @param {*} args
       */

    }, {
      key: "emit",
      value: function emit(event) {
        for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
          args[_key2 - 1] = arguments[_key2];
        }

        this.dispatch.apply(this, [event].concat(args));
      }
      /**
       * Returns channe by event name
       *
       * @param {String} event
       * @returns {Channel}
       * @private
       */

    }, {
      key: "_getChannel",
      value: function _getChannel(event) {
        if (!this._channels.has(event)) {
          this._channels.set(event, new Channel(event));
        }

        return this._channels.get(event);
      }
    }]);

    return EventEmitter;
  }();

  /**
   * Subscription item
   * @private
   */
  var SubscriptionItem =
  /*#__PURE__*/
  function () {
    /**
     * Constructor
     *
     * @param {Object} params
     * @param {Object} params.channel
     * @param {String} [params.event]
     * @param {Function} params.listener
     */
    function SubscriptionItem(params) {
      _classCallCheck(this, SubscriptionItem);

      this._params = params;
      this._isOn = false;

      this._assertParams();
    }
    /**
     * Turn on listener of channel
     */


    _createClass(SubscriptionItem, [{
      key: "on",
      value: function on() {
        if (!this._isOn) {
          var channel = this._params.channel;
          var method = channel.addListener || channel.addEventListener || channel.on;

          this._applyMethod(method);

          this._isOn = true;
        }
      }
      /**
       * Turn off listener of channel
       */

    }, {
      key: "off",
      value: function off() {
        if (this._isOn) {
          var channel = this._params.channel;
          var method = channel.removeListener || channel.removeEventListener || channel.off;

          this._applyMethod(method);

          this._isOn = false;
        }
      }
    }, {
      key: "_applyMethod",
      value: function _applyMethod(method) {
        var _this$_params = this._params,
            channel = _this$_params.channel,
            event = _this$_params.event,
            listener = _this$_params.listener;
        var args = event ? [event, listener] : [listener];
        method.apply(channel, args);
      }
    }, {
      key: "_assertParams",
      value: function _assertParams() {
        var _this$_params2 = this._params,
            channel = _this$_params2.channel,
            event = _this$_params2.event,
            listener = _this$_params2.listener;

        if (!channel || _typeof(channel) !== 'object') {
          throw new Error('Channel should be object');
        }

        if (event && typeof event !== 'string') {
          throw new Error('Event should be string');
        }

        if (!listener || typeof listener !== 'function') {
          throw new Error('Listener should be function');
        }
      }
    }]);

    return SubscriptionItem;
  }();

  /**
   * Utility class allowing dynamically attach/detach batch of listeners to event channels.
   *
   * @param {Array<{channel, event, listener}>} items
   *
   * @example
   * import Channel from 'chnl';
   * const subscription = new Channel.Subscription([
   *   {
   *     channel: chrome.tabs.onUpdated,
   *     listener: this._onTabUpdated.bind(this)
   *   }
   * ]);
   *
   * // attach listeners
   * subscription.on();
   * // detach listeners
   * subscription.off();
   */

  var Subscription =
  /*#__PURE__*/
  function () {
    function Subscription(items) {
      _classCallCheck(this, Subscription);

      this._items = items.map(function (params) {
        return new SubscriptionItem(params);
      });
    }
    /**
     * Turn on all listeners
     *
     * @returns {Subscription}
     */


    _createClass(Subscription, [{
      key: "on",
      value: function on() {
        this._items.forEach(function (item) {
          return item.on();
        });

        return this;
      }
      /**
       * Turn off all listeners
       *
       * @returns {Subscription}
       */

    }, {
      key: "off",
      value: function off() {
        this._items.forEach(function (item) {
          return item.off();
        });

        return this;
      }
    }]);

    return Subscription;
  }();

  /**
   * Utility class that extends Subscription for using in ReactComponent - automatically attach/detach listeners
   * in `componentDidMount` / `componentWillUnmount`.
   *
   * @param {ReactComponent} component
   * @param {Array<{channel, event, listener}>} items
   *
   * @example
   * class Button extends React.Component {
   *   constructor() {
   *     super();
   *     new Channel.ReactSubscription(this, [
   *       {channel: onNewData, listener: this.handleNewData.bind(this)}
   *     ]);
   *   }
   * }
   *
   * // actually equals to (but with more boilerplate code):
   * class Button extends React.Component {
   *   constructor() {
   *     super();
   *     this.subscription = new Channel.Subscription([
   *       {channel: onNewData, listener: this.handleNewData.bind(this)}
   *     ]);
   *   }
   *   componentDidMount() {
   *     this.subscription.on();
   *   }
   *   componentWillUnmount() {
   *     this.subscription.off();
   *   }
   * }
   */

  var ReactSubscription =
  /*#__PURE__*/
  function (_Subscription) {
    _inherits(ReactSubscription, _Subscription);

    function ReactSubscription(component, items) {
      var _this;

      _classCallCheck(this, ReactSubscription);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(ReactSubscription).call(this, items));

      _this._overrideComponentCallback(component, 'componentDidMount', 'on');

      _this._overrideComponentCallback(component, 'componentWillUnmount', 'off');

      return _this;
    }
    /**
     * @param {ReactComponent} component
     * @param {String} callbackName
     * @param {String} methodName
     * @private
     */


    _createClass(ReactSubscription, [{
      key: "_overrideComponentCallback",
      value: function _overrideComponentCallback(component, callbackName, methodName) {
        var _this2 = this;

        var baseCallback = component[callbackName];

        component[callbackName] = function () {
          _this2[methodName]();

          if (typeof baseCallback === 'function') {
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }

            return baseCallback.apply(component, args);
          }
        };
      }
    }]);

    return ReactSubscription;
  }(Subscription);

  /**
   * Chnl entry point
   */
  /**
   * @private
   */

  var chnl = Channel;
  chnl.EventEmitter = EventEmitter;
  chnl.Subscription = Subscription;
  chnl.ReactSubscription = ReactSubscription;
  /*
   Can not export additional classes like:

   export {
   EventEmitter,
   Subscription,
   };

   because in that case babel's output is not compatible with pure commonjs
   See: http://stackoverflow.com/questions/33505992/babel-6-changes-how-it-exports-default
   */

  return chnl;

}));
